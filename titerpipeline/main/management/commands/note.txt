import json
import os
from main.models import Experiment, Sample, Sample_Metadata, Read_Pair  
from django.core.management.base import BaseCommand
from datetime import datetime 
import random # for plate num. Delete once ready to deploy

class Command(BaseCommand):
    def handle(self, *args, **kwargs):
        # Determine the correct path to the JSON file
        base_dir = os.path.dirname(os.path.abspath(__file__))  # Dynamic path to json file
        json_file_path = os.path.join(base_dir, 'cleaned_migration.json')

        # Load JSON data from file
        with open(json_file_path, 'r') as file:  
            data = json.load(file)

        # Iterate over each JSON item (record)
        for item in data:
            experiment_name = item.get('Experiment ID')  
            sample_id = item.get('Sample ID')    
            created_date_str = item.get('Date Collected')

            # Parse 'Date Collected' to datetime if present and valid
            if created_date_str:
                try: 
                    created_date = datetime.strptime(created_date_str, '%Y-%m-%dT%H:%M:%S.%fZ').date() 
                except ValueError:
                    self.stdout.write(self.style.ERROR(f"Invalid date format for sample '{sample_id}': {created_date_str}"))
                    created_date = None  # Set to None if invalid format
            else:
                created_date = None  # Default to None if no date

            # Extract metadata fields
            sample_label = item.get('Sample Label')      
            metadata = {
                "Cell_Line": item.get('Cell Line'),
                "Infection": item.get('Infection'),
                "Initials": item.get('Initials'),
                "Split (DDMMRep)": item.get('Split (DDMMRep)'),
                "Species": item.get('Species'),
                'Replicate': item.get('Pellet Replicate'),
                "Extraction Date": item.get('Extraction Date'),
                "Timepoint": item.get('Timepoint'),
            }  
            read1_path = f"/path/to/read1_{sample_id}.fastq" 
            read2_path = f"/path/to/read2_{sample_id}.fastq"  
            plate_number = random.randint(1, 4)  # Replace this once ready to deploy

            # Step 1: Get or create the experiment
            experiment, created = Experiment.objects.get_or_create(name=experiment_name)
            if created:
                self.stdout.write(f"Created new experiment: {experiment.name}")

            # Step 2: Get or create the sample (avoid duplication by using sample_id as the unique identifier)
            sample, created = Sample.objects.get_or_create(
                sample_id=sample_id,
                defaults={
                    'created_date': created_date,
                    'experiment': experiment,
                    'sample_label': sample_label
                }
            )
            if created:
                self.stdout.write(f"Created new sample: {sample.sample_id}")
            else:
                # Optionally, update existing fields if necessary
                sample.created_date = created_date
                sample.sample_label = sample_label
                sample.save()

            # Step 3: Get or create the sample metadata
            sample_metadata, created = Sample_Metadata.objects.get_or_create(
                sample_id=sample,
                defaults={'metadata': metadata}
            )
            if created:
                self.stdout.write(f"Created metadata for sample: {sample.sample_id}")
            else:
                # Optionally update metadata if necessary
                sample_metadata.metadata = metadata
                sample_metadata.save()

            # Step 4: Get or create the read pair (use read1_path and sample_id as unique keys)
            read_pair, created = Read_Pair.objects.get_or_create(
                read1_path=read1_path,
                sample_id=sample,
                defaults={
                    'read2_path': read2_path,
                    'plate_number': plate_number
                }
            )
            if created:
                self.stdout.write(f"Created read pair for sample: {sample.sample_id}")
            else:
                # Optionally update the read paths or plate number if necessary
                read_pair.read2_path = read2_path
                read_pair.plate_number = plate_number
                read_pair.save()

